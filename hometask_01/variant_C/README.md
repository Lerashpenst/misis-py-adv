# Вариант С

Ваша задача: реализовать **логгер**.

В файле вам дается шаблон с сигнатурами классов и всех методов, которые вам нужно реализовать. В функции `test()` приводятся примеры работы с классом. Ваш код должен как минимум соответствовать им (не выдавать `AssertionError` при запуске).

**Очень приветствуется** наличие документации к функциям, которые вы реализуете, которые описывают, что и как делает эта функция.

**Очень-очень приветствуется** правильное форматирование кода в соответствии с [codestyle](https://www.python.org/dev/peps/pep-0008/)-ом.

## Логгер

Логгер представляет из себя объект, отвечающий за сохранение требуемой информации в некоторый файл или поток. Чаще всего логгеры занимаются сохранением информации о произошедшем событии (event logging) или информации о состоянии (state logging).

![Пример логгера](../../img/logger_scheme_example.png)

В нашем случае логгер будет просто получать на вход сообщения и в определенном формате записывать их в файл/консоль.

Объект логгера должен существовать в единственном экземпляре, чтобы не возникало конфликтов записи. Для этого мы используем приватный классовый атрибут `_logger`, который будет хранить ссылку на существующий логгер. Создавать логгер мы будет не с помощью конструктора, а с помощью классового метода `get_logger`, который будет создавать логгер или возвращать ссылку на него, если таковой уже имеется в `_logger`.

## `class Logger`

### классовый атрибут `_logger`

Хранит в себе ссылку на объект логгера, если такой существует. Изначально инициализируется `None`-ом. Когда первый раз будет вызван метод `get_logger`, этот объект должен быть создан и ссылка на него положена в `_logger`.

### классовый атрибут `template`

Хранит в себе строку с шаблоном для сообщения. В эту строку будут форматироваться данные (само сообщение и время его отправки). В таком виде сообщения будут печататься.

### конструктор `__init__`

Опционально принимает строку с адресом файла, в который вести логгирование. По умолчанию принимает значение `None`. В таком случае вывод должен происходить в консоль (stdout).

*Подсказка:* Конструктор должен вызывать метод `set_output`.

### атрибут `stream`

Хранит в себе ссылку на поток записи. В случае записи в файл, там хранится то, что возвращает метод `open(...)`. В случае записи в консоль там должен лежать `sys.stdout` (модуль `sys`).

### `set_output`

Принимает опциональную строку и устанавливает её в качестве нового output-файла логгера. Также обновляет атрибут `stream` в соответствии с новым значением output-файла.

### классовый метод `get_logger`

Возвращает логгер, если он уже существует в `_logger`. Если нет, создает новый логгер с помощью конструктора, сохраняет ссылку на него в `_logger` и возвращает его.

### `__repr__`

Возвращает строковое представление логгера в формате:

```
<Logger *path*>
```

где вместо `*path*` стоит путь к файлу, в который ведется запись. Если запись ведется в консоль, там должно быть "stdout":

```
<Logger stdout>
```

### статический метод `time`

Возвращает текущие дату и время в виде *строки*.

Пример:

```
>>> logger.time()
2020-02-28 20:48:48.198280
```

*Подсказка:* используйте модуль `datetime`. В нем есть полезный метод `now`.

### `write`

Принимает на вход сообщение. Подставляет его и текущее время в шаблон и выводит результат. Вывод необходимо производить в поток, который хранится в `self.stream`.

Пример:
```
>>> logger.write('Hello, world!')
[2020-02-28 20:58:29.472356] Hello, world!
```

*Подсказка:* у встроенное функции `print` есть полезный аргумент `file`, который позволяет печатать в любой поток.

### `close`

Закрывает текущий поток — вызывает метод `close` у `self.stream`. После этого попытка записать в логгер будет вызывать ошибку.

## Оценивание

Ваш класс будет протестирован на некотором наборе тестов. В зависимостии от количества пройденных тестов выставляется балл.

Балл может быть повышен или понижен из-за плохого codestyle-а или отсутствия хотя бы небольших комментариев.

Пишите красиво, ваш код будут читать :)
