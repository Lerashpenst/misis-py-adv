# Вариант А

Ваша задача: реализовать **[бинарное дерево](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)**.

В файле вам дается шаблон с сигнатурами классов и всех методов, которые вам нужно реализовать. В функции `test()` приводятся примеры работы с классом. Ваш код должен как минимум соответствовать им (не выдавать `AssertionError` при запуске).

**Очень приветствуется** наличие документации к функциям, которые вы реализуете, которые описывают, что и как делает эта функция.

**Очень-очень приветствуется** правильное форматирование кода в соответствии с [codestyle](https://www.python.org/dev/peps/pep-0008/)-ом.

## Бинарное дерево

<img src="../../img/binary_tree_example.png" height="300">

Бинарное (двоичное) дерево представляет из себя структуру данных, хранящую в себе некое (вообще говоря произвольное) значение и ссылки на два своих поддерева — левое и правое. Любая из этих ссылок может быть пустой (`None`). Если обе ссылки пустые, считается, что эта вершина дерева — листовая. На картинке выше такими вершинами являются `4`, `7` и `13`.

## `class BinTree`

Вам необходимо реализовать данный класс (по сути "заполнить" функции). Ниже приводятся описания атрибутов, функций и их параметров.

### атрибут `value_type`

Классовый атрибут. Хранит в себе множетсво допускаемых к хранению в дереве типов. В данном классе никаких ограничений на тип хранимого значения не накладывается, поэтому кортеж пустой. В случае, когда необходимо ограничить набор принимаемых типов (см. `BinIntTree`), необходимо просто добавить их в этот кортеж.

### классовый метод `validate`

Метод проверяет, подходит ли нам тип данного значения. Подходящие типы указываются в `value_type`. Если там пусто, значит нам подходит любой тип. Если тип не соответствует требуемому, вызывается исключение `TypeError`. Если тип соответствует требованиям, метод возвращает саму строку.

*Подсказка:* используйте встроенную функцию `isinstance`.

### конструктор `__init__`

Параметры:

* `value` — значение, которое будет храниться в данной вершине дерева. Обязательный параметр. Значение необходимо валидировать перед сохранением при помощи метода `validate`. Доступ к этому значению будет осуществляться с помощью property-методов (не напрямую!).

* `left`, `right` — левое и правое поддерево этой вершины. Если какой-то из этих параметров не передать, он по умолчанию примет значение `None`, что интерпретируется как отсутствие у данной вершины этого поддерева.

### свойство `value`

Вам необходимо реализовать два метода, отвечающие за получение и задание хранимого значения. Метод с декоратором `@property` возвращает текущее значение `value`. Метод с декоратором `@value.setter` присваивает текущему значение новое (и ничего не возвращает). 

Значение перед присвоением должно валидироваться методом `validate`.

### метод `__repr__`

Метод должен возвращать строковое представление объекта в формате:
```
<ClassName value>
```
где вместо `Classname` указывается имя данного класса, а вместо `value` указывается текущее значение `value`.

Обратите внимание на формат этой строки! Угловые скобочки обязательны. Имя класса должно определяться динамически, т.е. для наследников данного класса этот метод должен писать именно имя наследника.

Пример (класс `BinTree`, `value = 42`):
```
<BinTree 42>
```

Пример (класс `BinIntTree`, его наследник):
```
<BinIntTree 42>
```

*Подсказка:* используйте атрибут `self.__class__`. У него в свою очередь есть полезный атрибут `__name__`.

### метод `__iter__`

Должен возвращать итератор, определенный методом `dfs`.

### метод `dfs`

Это функция-генератор. Она должна выдавать объекты в порядке [deep-first-search](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83) (dfs, поиск в глубину).

Пример:
```
     1
    / \
   2   3
  / \
 4   5
```

```
>>> list(tree.dfs())
[<BinTree 1>, <BinTree 2>, <BinTree 4>, <BinTree 5>, <BinTree 3>]
```

*Подсказка:* используйте операторы `yield` и `yield from`. Поскольку для каждого нашего дерева будет определен метод `__iter__`, значит по каждому нашему дереву можно итерироваться, то есть передавать его `yield from`-у.


### свойство `is_leaf`

Свойство возвращает значения `True` или `False` в зависимости от того, является ли данная вершина листовой.

## `class BinIntTree`

Этот класс представляет из себя бинарное дерево, хранящее целые числа (`int`-ы). Все необходимое для него уже есть, осталось только обратить внимание на атрибут `value_type`.

### метод `min`

Возвращает вершину с наименьшим значением `value`.

*Подсказка:* наше дерево — iterable, а значит его можно передавать в функцию `min`. У функции `min` есть дополнительный параметр `key`, который позволит нам сравнивать два дерева по значению `value`.

### метод `max`

Возвращает вершину с наибольшим значением `value`.

## Оценивание

Ваш класс будет протестирован на некотором наборе тестов. В зависимостии от количества пройденных тестов выставляется балл.

Балл может быть повышен или понижен из-за плохого codestyle-а или отсутствия хотя бы небольших комментариев.

Пишите красиво, ваш код будут читать :)
